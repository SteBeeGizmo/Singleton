{"name":"Singleton","tagline":"A useful implementation of the singleton pattern for Unity3d","body":"##Singleton\r\n#### A useful implementation of the singleton pattern for Unity3d\r\n\r\nThe [singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern) is a very common way to share data and methods across classes in Unity. This code provides an easy-to-use implementation of this pattern that satisfies three goals:\r\n* _Minimal clutter in singleton classes:_ All a singleton need do is derive from Singleton<T> rather than MonoBehaviour, and then call base.onAwake() in its Awake() method.\r\n* _Supports both lazy and explicit instantiation:_ When a singleton is referenced, if it already exists that instance is used; if it doesn't exist, a new instance is created.\r\n* _Supports both global and scene-level singletons:_ Usually you want your singletons to persist across scene changes, but sometimes you want a singleton to be flushed out of memory when a new scene is loaded. Both options are available with this system.\r\n\r\n### Usage\r\n1. Derive your singleton component from `Singleton<T>` rather than `MonoBehaviour`. Replace the `T` with the name of your class.\r\n2. You must call `onAwake()` in your component's `Awake()` method.\r\n3. [Optional] If you want your component to be destroyed when a new scene is loaded, you must override `isGlobalScope` to return `false`. You must also give it an OnDestroy handler: `void OnDestroy() { base.onDestroy(); }`\r\n\r\nAs part of the initialization process, every singleton is renamed with an underscore followed by the name of the class. \r\nWhen a singleton is lazily instantiated, it is created as the child of a `GameObject` at the root named `_SingletonManager`, and its name is followed with \" [autogenerated]\".\r\n\r\nIf an instance of a singleton is explicitly instantiated while another instance already exists, the new instance is destroyed and a warning is reported. It is thus safe to explicitly instantiate singletons in each of your scenes if desired.\r\n\r\nEach singleton is accessed via `ClassName.Instance`. For the convenience your callers, you might want to create static methods and properties of your singletons. Just have such methods reference `ClassName.Instance` internally. Because of lazy instantiation, this property will never return null, unless something unrecoverably disastrous has happened.\r\n\r\n#### Example\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class YourSingletonClass : Singleton<YourSingletonClass>\r\n{\r\n\tvoid Awake()\r\n\t{\r\n\t\t// You MUST call the base class onAwake() method\r\n\t\t//\tbefore you exit Awake().\r\n\t\tonAwake();\r\n\t}\r\n\r\n\tpublic bool SomeOtherClassExistsNow = false;\r\n\t\r\n\tpublic float Scale = 0.5f;\r\n\t\r\n\tpublic void static SetScale(GameObject target)\r\n\t{\r\n\t  target.transform.localScale = Vector3.one * YourSingletonClass.Instance.Scale;\r\n\t}\r\n}\r\n```\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections;\r\n\r\npublic class SomeOtherClass : MonoBehaviour\r\n{\r\n  void Start()\r\n  {\r\n    YourSingletonClass.Instance.SomeOtherClassExistsNow = true;\r\n    \r\n    YourSingletonClass.SetScale(gameObject);\r\n  }\r\n}\r\n```\r\n\r\n#### Other Classes\r\nThis code includes a couple of existing singletons, both as an example of usage and to provide services that the singleton system itself needs.\r\n* `DebugManager`: Wraps access to Unity's `Debug.Log()` method, to simply string formatting and to allow logging to be disabled in release builds.\r\n* `GlobalsManager`: A simple class for storing global variables, such as config settings.\r\n\r\n### Design & Acknowledgements\r\nThe basic trick of this code, the \"self-referential generic class\", comes from the terrific article, [\"50 Tips for Working with Unity\"](http://devmag.org.za/2012/07/12/50-tips-for-working-with-unity-best-practices/) by Herman Tulleken.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}